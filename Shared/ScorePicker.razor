@using BlazorBootstrap
@inject IJSRuntime JS

<Modal @ref="_modal" Title="Set score" IsVerticallyCentered="true" Size="ModalSize.Large">
    <HeaderTemplate>
        <strong>Set score @(_match?.CourtName)</strong>
    </HeaderTemplate>

    <BodyTemplate>
        <div class="mb-2 small text-muted d-flex align-items-center justify-content-between">
            <div>
                To points: <strong>@ToPoints</strong> · Team <strong>@_team</strong>
            </div>
            @if (!string.IsNullOrEmpty(_typed))
            {
                <div class="badge text-bg-secondary">typed: @_typed</div>
            }
        </div>

        <div class="score-grid">
            @foreach (var v in Enumerable.Range(0, ToPoints + 1))
            {
                <Button Color="ButtonColor.Secondary"
                        Class="w-100"
                        @onclick="(() => Pick(v))">
                    @v
                </Button>
            }
        </div>
    </BodyTemplate>
</Modal>

@code {
    [Parameter] public int ToPoints { get; set; } = 21;

    public sealed class ScorePickArgs
    {
        public required Match Match { get; init; }
        public required int Team { get; init; }
        public required int Selected { get; init; }
    }

    [Parameter] public EventCallback<ScorePickArgs> OnPick { get; set; }

    private Modal _modal = default!;
    private Match? _match;
    private int _team;

    private IJSObjectReference? _module;
    private DotNetObjectReference<ScorePicker>? _selfRef;
    private string _typed = string.Empty;

    public async Task ShowAsync(Match match, int team, int toPoints)
    {
        _match = match;
        _team = team;
        ToPoints = toPoints;
        _typed = string.Empty;

        _module ??= await JS.InvokeAsync<IJSObjectReference>("import", "./scorePicker.js");
        _selfRef ??= DotNetObjectReference.Create(this);
        await _module.InvokeVoidAsync("attach", _selfRef);

        await _modal.ShowAsync();
    }

    public async Task Close()
    {
        _typed = string.Empty;
        if (_module is not null) await _module.InvokeVoidAsync("detach");
        await _modal.HideAsync();
    }

    private async Task Pick(int selected)
    {
        selected = Math.Clamp(selected, 0, ToPoints);
        await OnPick.InvokeAsync(new ScorePickArgs
        {
            Match = _match!,
            Team = _team,
            Selected = selected
        });
        _typed = string.Empty;
        await Close();
    }

    [JSInvokable]
    public async Task HandleKeyFromJs(string key)
    {
        if (key == "Escape") { await Close(); return; }

        if (key == "Backspace")
        {
            if (!string.IsNullOrEmpty(_typed)) _typed = _typed[..^1];
            StateHasChanged();
            return;
        }

        if (key == "Enter")
        {
            if (int.TryParse(_typed, out var entered) && entered <= ToPoints)
                await Pick(entered);
            return;
        }

        if (key.Length == 1 && char.IsDigit(key[0]))
        {
            _typed += key;
            _typed = _typed.TrimStart('0');
            if (string.IsNullOrEmpty(_typed)) _typed = "0";

            if (!int.TryParse(_typed, out var val))
            {
                _typed = string.Empty;
                StateHasChanged();
                return;
            }

            if (val > ToPoints)
            {
                _typed = _typed.Length > 1 ? _typed[..^1] : string.Empty;
                StateHasChanged();
                return;
            }

            if (ToPoints >= 10)
            {
                if (_typed.Length >= 2)
                {
                    await Pick(val);
                    return;
                }
            }
            else
            {
                await Pick(val);
                return;
            }

            StateHasChanged();
        }
    }

    public async ValueTask DisposeAsync()
    {
        try { if (_module is not null) await _module.InvokeVoidAsync("detach"); }
        catch { /* ignore */ }
        _selfRef?.Dispose();
        if (_module is not null)
        {
            try { await _module.DisposeAsync(); } catch { }
            _module = null;
        }
    }
}
